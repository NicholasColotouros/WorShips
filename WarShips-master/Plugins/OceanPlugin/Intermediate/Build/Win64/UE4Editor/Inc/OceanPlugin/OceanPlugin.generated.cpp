// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Classes/OceanPluginPrivatePCH.h"
#include "OceanPlugin.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeOceanPlugin() {}
class UScriptStruct* FWaveSetParameters::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FWaveSetParameters();
		extern OCEANPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC();
		extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage_OceanPlugin();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FWaveSetParameters, Z_Construct_UPackage_OceanPlugin(), TEXT("WaveSetParameters"), sizeof(FWaveSetParameters), Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FWaveSetParameters(FWaveSetParameters::StaticStruct, TEXT("/Script/OceanPlugin"));
static struct FScriptStruct_OceanPlugin_StaticRegisterNativesFWaveSetParameters
{
	FScriptStruct_OceanPlugin_StaticRegisterNativesFWaveSetParameters()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("WaveSetParameters")),new UScriptStruct::TCppStructOps<FWaveSetParameters>);
	}
} ScriptStruct_OceanPlugin_StaticRegisterNativesFWaveSetParameters;
class UScriptStruct* FWaveParameter::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FWaveParameter();
		extern OCEANPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FWaveParameter_CRC();
		extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage_OceanPlugin();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FWaveParameter, Z_Construct_UPackage_OceanPlugin(), TEXT("WaveParameter"), sizeof(FWaveParameter), Get_Z_Construct_UScriptStruct_FWaveParameter_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FWaveParameter(FWaveParameter::StaticStruct, TEXT("/Script/OceanPlugin"));
static struct FScriptStruct_OceanPlugin_StaticRegisterNativesFWaveParameter
{
	FScriptStruct_OceanPlugin_StaticRegisterNativesFWaveParameter()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("WaveParameter")),new UScriptStruct::TCppStructOps<FWaveParameter>);
	}
} ScriptStruct_OceanPlugin_StaticRegisterNativesFWaveParameter;
	void AOceanManager::StaticRegisterNativesAOceanManager()
	{
		FNativeFunctionRegistrar::RegisterFunction(AOceanManager::StaticClass(),"GetWaveHeightValue",(Native)&AOceanManager::execGetWaveHeightValue);
	}
	IMPLEMENT_CLASS(AOceanManager, 4247754154);
	void UBuoyancyComponent::StaticRegisterNativesUBuoyancyComponent()
	{
	}
	IMPLEMENT_CLASS(UBuoyancyComponent, 467986254);
class UScriptStruct* FStructBoneOverride::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FStructBoneOverride();
		extern OCEANPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC();
		extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage_OceanPlugin();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FStructBoneOverride, Z_Construct_UPackage_OceanPlugin(), TEXT("StructBoneOverride"), sizeof(FStructBoneOverride), Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FStructBoneOverride(FStructBoneOverride::StaticStruct, TEXT("/Script/OceanPlugin"));
static struct FScriptStruct_OceanPlugin_StaticRegisterNativesFStructBoneOverride
{
	FScriptStruct_OceanPlugin_StaticRegisterNativesFStructBoneOverride()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("StructBoneOverride")),new UScriptStruct::TCppStructOps<FStructBoneOverride>);
	}
} ScriptStruct_OceanPlugin_StaticRegisterNativesFStructBoneOverride;
	void UBuoyancyForceComponent::StaticRegisterNativesUBuoyancyForceComponent()
	{
	}
	IMPLEMENT_CLASS(UBuoyancyForceComponent, 368820851);
	void UBuoyantDestructibleComponent::StaticRegisterNativesUBuoyantDestructibleComponent()
	{
	}
	IMPLEMENT_CLASS(UBuoyantDestructibleComponent, 3166210357);
	void ABuoyantDestructible::StaticRegisterNativesABuoyantDestructible()
	{
	}
	IMPLEMENT_CLASS(ABuoyantDestructible, 1829908850);
	void ACustomVehicleController::StaticRegisterNativesACustomVehicleController()
	{
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(),"DrawBuoyancyPoints",(Native)&ACustomVehicleController::execDrawBuoyancyPoints);
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(),"EnableBuoyancy",(Native)&ACustomVehicleController::execEnableBuoyancy);
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(),"EnterVehicle",(Native)&ACustomVehicleController::execEnterVehicle);
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(),"ExitVehicle",(Native)&ACustomVehicleController::execExitVehicle);
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(),"GetIsDriving",(Native)&ACustomVehicleController::execGetIsDriving);
	}
	IMPLEMENT_CLASS(ACustomVehicleController, 946884128);
	void AFishManager::StaticRegisterNativesAFishManager()
	{
	}
	IMPLEMENT_CLASS(AFishManager, 3518155784);
	void AFlockFish::StaticRegisterNativesAFlockFish()
	{
		FNativeFunctionRegistrar::RegisterFunction(AFlockFish::StaticClass(),"OnBeginOverlap",(Native)&AFlockFish::execOnBeginOverlap);
		FNativeFunctionRegistrar::RegisterFunction(AFlockFish::StaticClass(),"OnEndOverlap",(Native)&AFlockFish::execOnEndOverlap);
	}
	IMPLEMENT_CLASS(AFlockFish, 4096035236);
static class UEnum* EFollowMethod_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UEnum* Z_Construct_UEnum_OceanPlugin_EFollowMethod();
		extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage_OceanPlugin();
		Singleton = GetStaticEnum(Z_Construct_UEnum_OceanPlugin_EFollowMethod, Z_Construct_UPackage_OceanPlugin(), TEXT("EFollowMethod"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EFollowMethod(EFollowMethod_StaticEnum, TEXT("/Script/OceanPlugin"));
	void UInfiniteSystemComponent::StaticRegisterNativesUInfiniteSystemComponent()
	{
	}
	IMPLEMENT_CLASS(UInfiniteSystemComponent, 1104387495);
class UScriptStruct* FTimeDate::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FTimeDate();
		extern OCEANPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FTimeDate_CRC();
		extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage_OceanPlugin();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FTimeDate, Z_Construct_UPackage_OceanPlugin(), TEXT("TimeDate"), sizeof(FTimeDate), Get_Z_Construct_UScriptStruct_FTimeDate_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FTimeDate(FTimeDate::StaticStruct, TEXT("/Script/OceanPlugin"));
static struct FScriptStruct_OceanPlugin_StaticRegisterNativesFTimeDate
{
	FScriptStruct_OceanPlugin_StaticRegisterNativesFTimeDate()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("TimeDate")),new UScriptStruct::TCppStructOps<FTimeDate>);
	}
} ScriptStruct_OceanPlugin_StaticRegisterNativesFTimeDate;
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	ENGINE_API class UClass* Z_Construct_UClass_AActor();
	ENGINE_API class UClass* Z_Construct_UClass_UMovementComponent();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	ENGINE_API class UClass* Z_Construct_UClass_USceneComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETickingGroup();
	ENGINE_API class UClass* Z_Construct_UClass_UDestructibleComponent();
	ENGINE_API class UClass* Z_Construct_UClass_APawn_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerController();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject_NoRegister();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FHitResult();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APawn();
	ENGINE_API class UClass* Z_Construct_UClass_USphereComponent_NoRegister();

	OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FWaveSetParameters();
	OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FWaveParameter();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_AOceanManager_GetWaveHeightValue();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AOceanManager_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AOceanManager();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyancyComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyancyComponent();
	OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FStructBoneOverride();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyancyForceComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyancyForceComponent();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyantDestructibleComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyantDestructibleComponent();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ABuoyantDestructible_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ABuoyantDestructible();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_DrawBuoyancyPoints();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_EnableBuoyancy();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_EnterVehicle();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_ExitVehicle();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_GetIsDriving();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ACustomVehicleController_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ACustomVehicleController();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AFishManager_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AFishManager();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_AFlockFish_OnBeginOverlap();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_AFlockFish_OnEndOverlap();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AFlockFish_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AFlockFish();
	OCEANPLUGIN_API class UEnum* Z_Construct_UEnum_OceanPlugin_EFollowMethod();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UInfiniteSystemComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UInfiniteSystemComponent();
	OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FTimeDate();
	OCEANPLUGIN_API class UPackage* Z_Construct_UPackage_OceanPlugin();
	UScriptStruct* Z_Construct_UScriptStruct_FWaveSetParameters()
	{
		UPackage* Outer=Z_Construct_UPackage_OceanPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("WaveSetParameters"), sizeof(FWaveSetParameters), Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("WaveSetParameters"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FWaveSetParameters>, EStructFlags(0x00000001));
			UProperty* NewProp_Wave08 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave08"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Wave08, FWaveSetParameters), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave07 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave07"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Wave07, FWaveSetParameters), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave06 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave06"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Wave06, FWaveSetParameters), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave05 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave05"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Wave05, FWaveSetParameters), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave04 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave04"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Wave04, FWaveSetParameters), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave03 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave03"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Wave03, FWaveSetParameters), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave02 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave02"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Wave02, FWaveSetParameters), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave01 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave01"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Wave01, FWaveSetParameters), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("* Contains the parameters necessary for a set of Gerstner waves."));
			MetaData->SetValue(NewProp_Wave08, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave08, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave07, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave07, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave06, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave06, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave05, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave05, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave04, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave04, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave03, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave03, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave02, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave02, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave01, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave01, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC() { return 2995088741U; }
	UScriptStruct* Z_Construct_UScriptStruct_FWaveParameter()
	{
		UPackage* Outer=Z_Construct_UPackage_OceanPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FWaveParameter_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("WaveParameter"), sizeof(FWaveParameter), Get_Z_Construct_UScriptStruct_FWaveParameter_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("WaveParameter"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FWaveParameter>, EStructFlags(0x00000001));
			UProperty* NewProp_Steepness = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Steepness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Steepness, FWaveParameter), 0x0000000000000005);
			UProperty* NewProp_Amplitude = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Amplitude"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Amplitude, FWaveParameter), 0x0000000000000005);
			UProperty* NewProp_Length = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Length"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Length, FWaveParameter), 0x0000000000000005);
			UProperty* NewProp_Rotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Rotation"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Rotation, FWaveParameter), 0x0000000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("* Contains the parameters necessary for a single Gerstner wave."));
			MetaData->SetValue(NewProp_Steepness, TEXT("Category"), TEXT("WaveParameter"));
			MetaData->SetValue(NewProp_Steepness, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Amplitude, TEXT("Category"), TEXT("WaveParameter"));
			MetaData->SetValue(NewProp_Amplitude, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Length, TEXT("Category"), TEXT("WaveParameter"));
			MetaData->SetValue(NewProp_Length, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Rotation, TEXT("Category"), TEXT("WaveParameter"));
			MetaData->SetValue(NewProp_Rotation, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FWaveParameter_CRC() { return 717779346U; }
	UFunction* Z_Construct_UFunction_AOceanManager_GetWaveHeightValue()
	{
		struct OceanManager_eventGetWaveHeightValue_Parms
		{
			FVector location;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AOceanManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWaveHeightValue"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(OceanManager_eventGetWaveHeightValue_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, OceanManager_eventGetWaveHeightValue_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_location = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("location"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(location, OceanManager_eventGetWaveHeightValue_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Ocean Manager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AOceanManager_NoRegister()
	{
		return AOceanManager::StaticClass();
	}
	UClass* Z_Construct_UClass_AOceanManager()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_OceanPlugin();
			OuterClass = AOceanManager::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;

				OuterClass->LinkChild(Z_Construct_UFunction_AOceanManager_GetWaveHeightValue());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_NetWorkTimeOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NetWorkTimeOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NetWorkTimeOffset, AOceanManager), 0x0000000000000004);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableGerstnerWaves, AOceanManager, bool);
				UProperty* NewProp_EnableGerstnerWaves = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableGerstnerWaves"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableGerstnerWaves, AOceanManager), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(EnableGerstnerWaves, AOceanManager), sizeof(bool), true);
				UProperty* NewProp_WaveSet1 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveSet1"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(WaveSet1, AOceanManager), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveSetParameters());
				UProperty* NewProp_GlobalWaveSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GlobalWaveSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(GlobalWaveSettings, AOceanManager), 0x0000000000000005, Z_Construct_UScriptStruct_FWaveParameter());
				UProperty* NewProp_WaveSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WaveSpeed, AOceanManager), 0x0000000000000005);
				UProperty* NewProp_WaveDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveDirection"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(WaveDirection, AOceanManager), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AOceanManager_GetWaveHeightValue()); // 3474868606
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("OceanManager.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("OceanManager calculates the Gerstner waves in code, while the Material uses it's own implementation in a MaterialFunction.\nTODO: Investigate whether a single implementation could be used to increase performance."));
				MetaData->SetValue(NewProp_NetWorkTimeOffset, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_NetWorkTimeOffset, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_EnableGerstnerWaves, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_EnableGerstnerWaves, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_WaveSet1, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_WaveSet1, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_WaveSet1, TEXT("ToolTip"), TEXT("Individual wave settings for wave set 1"));
				MetaData->SetValue(NewProp_GlobalWaveSettings, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_GlobalWaveSettings, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_GlobalWaveSettings, TEXT("ToolTip"), TEXT("The globally applied wave settings"));
				MetaData->SetValue(NewProp_WaveSpeed, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_WaveSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_WaveSpeed, TEXT("ToolTip"), TEXT("The speed of the waves"));
				MetaData->SetValue(NewProp_WaveDirection, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_WaveDirection, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_WaveDirection, TEXT("ToolTip"), TEXT("The Direction the waves travel"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AOceanManager(Z_Construct_UClass_AOceanManager, TEXT("AOceanManager"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AOceanManager);
	UClass* Z_Construct_UClass_UBuoyancyComponent_NoRegister()
	{
		return UBuoyancyComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBuoyancyComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UMovementComponent();
			Z_Construct_UPackage_OceanPlugin();
			OuterClass = UBuoyancyComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_WaveForceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveForceMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WaveForceMultiplier, UBuoyancyComponent), 0x0000040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableWaveForces, UBuoyancyComponent, bool);
				UProperty* NewProp_EnableWaveForces = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableWaveForces"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableWaveForces, UBuoyancyComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableWaveForces, UBuoyancyComponent), sizeof(bool), true);
				UProperty* NewProp_StayUprightDesiredRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightDesiredRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StayUprightDesiredRotation, UBuoyancyComponent), 0x0000040000000005, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_StayUprightDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StayUprightDamping, UBuoyancyComponent), 0x0000040000000005);
				UProperty* NewProp_StayUprightStiffness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StayUprightStiffness, UBuoyancyComponent), 0x0000040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableStayUprightConstraint, UBuoyancyComponent, bool);
				UProperty* NewProp_EnableStayUprightConstraint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableStayUprightConstraint"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableStayUprightConstraint, UBuoyancyComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableStayUprightConstraint, UBuoyancyComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DrawDebugPoints, UBuoyancyComponent, bool);
				UProperty* NewProp_DrawDebugPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawDebugPoints"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DrawDebugPoints, UBuoyancyComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(DrawDebugPoints, UBuoyancyComponent), sizeof(bool), true);
				UProperty* NewProp_PointDensityOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PointDensityOverride"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(PointDensityOverride, UBuoyancyComponent), 0x0000040000000005);
				UProperty* NewProp_PointDensityOverride_Inner = new(EC_InternalUseOnlyConstructor, NewProp_PointDensityOverride, TEXT("PointDensityOverride"), RF_Public|RF_Transient|RF_Native) UFloatProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				UProperty* NewProp_TestPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPoints"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(TestPoints, UBuoyancyComponent), 0x0000000000000005);
				UProperty* NewProp_TestPoints_Inner = new(EC_InternalUseOnlyConstructor, NewProp_TestPoints, TEXT("TestPoints"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_TestPointRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPointRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TestPointRadius, UBuoyancyComponent), 0x0000000000000005);
				UProperty* NewProp_MaxUnderwaterVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxUnderwaterVelocity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxUnderwaterVelocity, UBuoyancyComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ClampMaxVelocity, UBuoyancyComponent, bool);
				UProperty* NewProp_ClampMaxVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ClampMaxVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ClampMaxVelocity, UBuoyancyComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(ClampMaxVelocity, UBuoyancyComponent), sizeof(bool), true);
				UProperty* NewProp_VelocityDamper = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VelocityDamper"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(VelocityDamper, UBuoyancyComponent), 0x0000040000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FluidAngularDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidAngularDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FluidAngularDamping, UBuoyancyComponent), 0x0000000000000005);
				UProperty* NewProp_FluidLinearDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidLinearDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FluidLinearDamping, UBuoyancyComponent), 0x0000000000000005);
				UProperty* NewProp_FluidDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidDensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FluidDensity, UBuoyancyComponent), 0x0000000000000005);
				UProperty* NewProp_MeshDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MeshDensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MeshDensity, UBuoyancyComponent), 0x0000000000000005);
				UProperty* NewProp_OceanManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OceanManager"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OceanManager, UBuoyancyComponent), 0x0000040000000005, Z_Construct_UClass_AOceanManager_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Movement"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("PlanarMovement Components|Movement|Planar Velocity ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyancyComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_StayUprightDesiredRotation, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightDesiredRotation, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_StayUprightDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_StayUprightStiffness, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("ToolTip"), TEXT("Stay upright physics constraint (inspired by UDK's StayUprightSpring)\n-STILL WIP-"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("ToolTip"), TEXT("Per-point mesh density override, can be used for half-sinking objects etc."));
				MetaData->SetValue(NewProp_TestPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_TestPoints, TEXT("ToolTip"), TEXT("Test point array. At least one point is required for buoyancy"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ToolTip"), TEXT("Radius of the points"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ToolTip"), TEXT("Angular damping when object is in fluid"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ToolTip"), TEXT("Linear damping when object is in fluid"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ToolTip"), TEXT("Density of water"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ToolTip"), TEXT("Density of mesh"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ToolTip"), TEXT("OceanManager used by the component, if unassign component will auto-detect"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBuoyancyComponent(Z_Construct_UClass_UBuoyancyComponent, TEXT("UBuoyancyComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBuoyancyComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FStructBoneOverride()
	{
		UPackage* Outer=Z_Construct_UPackage_OceanPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("StructBoneOverride"), sizeof(FStructBoneOverride), Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StructBoneOverride"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FStructBoneOverride>, EStructFlags(0x00000001));
			UProperty* NewProp_TestRadius = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TestRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TestRadius, FStructBoneOverride), 0x0000000000000005);
			UProperty* NewProp_Density = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Density"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Density, FStructBoneOverride), 0x0000000000000005);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, FStructBoneOverride), 0x0000000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Custom bone density/radius override struct."));
			MetaData->SetValue(NewProp_TestRadius, TEXT("Category"), TEXT("Buoyancy"));
			MetaData->SetValue(NewProp_TestRadius, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
			MetaData->SetValue(NewProp_Density, TEXT("Category"), TEXT("Buoyancy"));
			MetaData->SetValue(NewProp_Density, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
			MetaData->SetValue(NewProp_BoneName, TEXT("Category"), TEXT("Buoyancy"));
			MetaData->SetValue(NewProp_BoneName, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC() { return 3424145697U; }
	UClass* Z_Construct_UClass_UBuoyancyForceComponent_NoRegister()
	{
		return UBuoyancyForceComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBuoyancyForceComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_OceanPlugin();
			OuterClass = UBuoyancyForceComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_TickGroup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TickGroup"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(TickGroup, UBuoyancyForceComponent), 0x0000040000000005, Z_Construct_UEnum_Engine_ETickingGroup());
				UProperty* NewProp_WaveForceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveForceMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WaveForceMultiplier, UBuoyancyForceComponent), 0x0000040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableWaveForces, UBuoyancyForceComponent, bool);
				UProperty* NewProp_EnableWaveForces = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableWaveForces"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableWaveForces, UBuoyancyForceComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableWaveForces, UBuoyancyForceComponent), sizeof(bool), true);
				UProperty* NewProp_StayUprightDesiredRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightDesiredRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StayUprightDesiredRotation, UBuoyancyForceComponent), 0x0000040000000005, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_StayUprightDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StayUprightDamping, UBuoyancyForceComponent), 0x0000040000000005);
				UProperty* NewProp_StayUprightStiffness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StayUprightStiffness, UBuoyancyForceComponent), 0x0000040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableStayUprightConstraint, UBuoyancyForceComponent, bool);
				UProperty* NewProp_EnableStayUprightConstraint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableStayUprightConstraint"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableStayUprightConstraint, UBuoyancyForceComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableStayUprightConstraint, UBuoyancyForceComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DrawDebugPoints, UBuoyancyForceComponent, bool);
				UProperty* NewProp_DrawDebugPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawDebugPoints"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DrawDebugPoints, UBuoyancyForceComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(DrawDebugPoints, UBuoyancyForceComponent), sizeof(bool), true);
				UProperty* NewProp_BoneOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BoneOverride"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(BoneOverride, UBuoyancyForceComponent), 0x0000040000000005);
				UProperty* NewProp_BoneOverride_Inner = new(EC_InternalUseOnlyConstructor, NewProp_BoneOverride, TEXT("BoneOverride"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FStructBoneOverride());
				UProperty* NewProp_PointDensityOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PointDensityOverride"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(PointDensityOverride, UBuoyancyForceComponent), 0x0000040000000005);
				UProperty* NewProp_PointDensityOverride_Inner = new(EC_InternalUseOnlyConstructor, NewProp_PointDensityOverride, TEXT("PointDensityOverride"), RF_Public|RF_Transient|RF_Native) UFloatProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(SnapToSurfaceIfNoPhysics, UBuoyancyForceComponent, bool);
				UProperty* NewProp_SnapToSurfaceIfNoPhysics = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SnapToSurfaceIfNoPhysics"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(SnapToSurfaceIfNoPhysics, UBuoyancyForceComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(SnapToSurfaceIfNoPhysics, UBuoyancyForceComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ApplyForceToBones, UBuoyancyForceComponent, bool);
				UProperty* NewProp_ApplyForceToBones = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ApplyForceToBones"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ApplyForceToBones, UBuoyancyForceComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(ApplyForceToBones, UBuoyancyForceComponent), sizeof(bool), true);
				UProperty* NewProp_TestPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPoints"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(TestPoints, UBuoyancyForceComponent), 0x0000000000000005);
				UProperty* NewProp_TestPoints_Inner = new(EC_InternalUseOnlyConstructor, NewProp_TestPoints, TEXT("TestPoints"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_TestPointRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPointRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TestPointRadius, UBuoyancyForceComponent), 0x0000000000000005);
				UProperty* NewProp_MaxUnderwaterVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxUnderwaterVelocity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxUnderwaterVelocity, UBuoyancyForceComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ClampMaxVelocity, UBuoyancyForceComponent, bool);
				UProperty* NewProp_ClampMaxVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ClampMaxVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ClampMaxVelocity, UBuoyancyForceComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(ClampMaxVelocity, UBuoyancyForceComponent), sizeof(bool), true);
				UProperty* NewProp_VelocityDamper = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VelocityDamper"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(VelocityDamper, UBuoyancyForceComponent), 0x0000040000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FluidAngularDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidAngularDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FluidAngularDamping, UBuoyancyForceComponent), 0x0000000000000005);
				UProperty* NewProp_FluidLinearDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidLinearDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FluidLinearDamping, UBuoyancyForceComponent), 0x0000000000000005);
				UProperty* NewProp_FluidDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidDensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FluidDensity, UBuoyancyForceComponent), 0x0000000000000005);
				UProperty* NewProp_MeshDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MeshDensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MeshDensity, UBuoyancyForceComponent), 0x0000000000000005);
				UProperty* NewProp_OceanManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OceanManager"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OceanManager, UBuoyancyForceComponent), 0x0000040000000005, Z_Construct_UClass_AOceanManager_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility LOD PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyancyForceComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Applies buoyancy forces to physics objects.\nOceanManager is required in the level for this to work."));
				MetaData->SetValue(NewProp_TickGroup, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TickGroup, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("ToolTip"), TEXT("Waves will push objects towards the wave direction set in the Ocean Manager.\n-STILL WIP-"));
				MetaData->SetValue(NewProp_StayUprightDesiredRotation, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightDesiredRotation, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_StayUprightDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_StayUprightStiffness, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("ToolTip"), TEXT("Stay upright physics constraint (inspired by UDK's StayUprightSpring)\n-STILL WIP-"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_BoneOverride, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_BoneOverride, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_BoneOverride, TEXT("ToolTip"), TEXT("Density & radius overrides per skeletal bone (ApplyForceToBones needs to be true)."));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("ToolTip"), TEXT("Per-point mesh density override, can be used for half-sinking objects etc."));
				MetaData->SetValue(NewProp_SnapToSurfaceIfNoPhysics, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_SnapToSurfaceIfNoPhysics, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_SnapToSurfaceIfNoPhysics, TEXT("ToolTip"), TEXT("If object has no physics enabled, snap to water surface."));
				MetaData->SetValue(NewProp_ApplyForceToBones, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ApplyForceToBones, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_ApplyForceToBones, TEXT("ToolTip"), TEXT("If skeletal mesh with physics asset, it will apply buoyancy force at the COM of each bone instead of using the test point array."));
				MetaData->SetValue(NewProp_TestPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_TestPoints, TEXT("ToolTip"), TEXT("Test point array. At least one point is required for buoyancy."));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ToolTip"), TEXT("Radius of the points."));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ToolTip"), TEXT("Angular damping when object is in fluid."));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ToolTip"), TEXT("Linear damping when object is in fluid."));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ToolTip"), TEXT("Density of water. Typically you don't need to change this."));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ToolTip"), TEXT("Density of mesh."));
				MetaData->SetValue(NewProp_OceanManager, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ToolTip"), TEXT("OceanManager used by the component, if unassigned component will auto-detect"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBuoyancyForceComponent(Z_Construct_UClass_UBuoyancyForceComponent, TEXT("UBuoyancyForceComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBuoyancyForceComponent);
	UClass* Z_Construct_UClass_UBuoyantDestructibleComponent_NoRegister()
	{
		return UBuoyantDestructibleComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBuoyantDestructibleComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UDestructibleComponent();
			Z_Construct_UPackage_OceanPlugin();
			OuterClass = UBuoyantDestructibleComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A01080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ChunkStabilizationThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChunkStabilizationThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ChunkStabilizationThreshold, UBuoyantDestructibleComponent), 0x0000000000000005);
				UProperty* NewProp_ChunkSleepThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChunkSleepThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ChunkSleepThreshold, UBuoyantDestructibleComponent), 0x0000000000000005);
				UProperty* NewProp_WaveForceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveForceMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WaveForceMultiplier, UBuoyantDestructibleComponent), 0x0000040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableWaveForces, UBuoyantDestructibleComponent, bool);
				UProperty* NewProp_EnableWaveForces = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableWaveForces"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableWaveForces, UBuoyantDestructibleComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableWaveForces, UBuoyantDestructibleComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DrawDebugPoints, UBuoyantDestructibleComponent, bool);
				UProperty* NewProp_DrawDebugPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawDebugPoints"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DrawDebugPoints, UBuoyantDestructibleComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(DrawDebugPoints, UBuoyantDestructibleComponent), sizeof(bool), true);
				UProperty* NewProp_TestPointRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPointRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TestPointRadius, UBuoyantDestructibleComponent), 0x0000000000000005);
				UProperty* NewProp_MaxUnderwaterVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxUnderwaterVelocity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxUnderwaterVelocity, UBuoyantDestructibleComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ClampMaxVelocity, UBuoyantDestructibleComponent, bool);
				UProperty* NewProp_ClampMaxVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ClampMaxVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ClampMaxVelocity, UBuoyantDestructibleComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(ClampMaxVelocity, UBuoyantDestructibleComponent), sizeof(bool), true);
				UProperty* NewProp_VelocityDamper = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VelocityDamper"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(VelocityDamper, UBuoyantDestructibleComponent), 0x0000040000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FluidAngularDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidAngularDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FluidAngularDamping, UBuoyantDestructibleComponent), 0x0000000000000005);
				UProperty* NewProp_FluidLinearDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidLinearDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FluidLinearDamping, UBuoyantDestructibleComponent), 0x0000000000000005);
				UProperty* NewProp_FluidDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidDensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FluidDensity, UBuoyantDestructibleComponent), 0x0000000000000005);
				UProperty* NewProp_ChunkDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChunkDensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ChunkDensity, UBuoyantDestructibleComponent), 0x0000000000000005);
				UProperty* NewProp_OceanManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OceanManager"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OceanManager, UBuoyantDestructibleComponent), 0x0000040000000005, Z_Construct_UClass_AOceanManager_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mesh Components|SkinnedMesh Mirroring Activation Components|Activation Object Mesh Components|SkinnedMesh Mirroring Activation Components|Activation Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyantDestructibleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ChunkStabilizationThreshold, TEXT("Category"), TEXT("Advanced"));
				MetaData->SetValue(NewProp_ChunkStabilizationThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ChunkStabilizationThreshold, TEXT("ToolTip"), TEXT("* Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization.\n* (This value has no effect if PxSceneFlag::eENABLE_STABILIZATION was not enabled on the PxSceneDesc)"));
				MetaData->SetValue(NewProp_ChunkSleepThreshold, TEXT("Category"), TEXT("Advanced"));
				MetaData->SetValue(NewProp_ChunkSleepThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ChunkSleepThreshold, TEXT("ToolTip"), TEXT("* Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.\n* Default physx value is ~50.0f (we set it 0 to avoid weird sleeping chunks on water)."));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ToolTip"), TEXT("Radius of the test point"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ToolTip"), TEXT("Angular damping when chunk is in fluid"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ToolTip"), TEXT("Linear damping when chunk is in fluid"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ToolTip"), TEXT("Density of water"));
				MetaData->SetValue(NewProp_ChunkDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ChunkDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ChunkDensity, TEXT("ToolTip"), TEXT("Density of each chunk"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBuoyantDestructibleComponent(Z_Construct_UClass_UBuoyantDestructibleComponent, TEXT("UBuoyantDestructibleComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBuoyantDestructibleComponent);
	UClass* Z_Construct_UClass_ABuoyantDestructible_NoRegister()
	{
		return ABuoyantDestructible::StaticClass();
	}
	UClass* Z_Construct_UClass_ABuoyantDestructible()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_OceanPlugin();
			OuterClass = ABuoyantDestructible::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_BuoyantDestructibleComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BuoyantDestructibleComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(BuoyantDestructibleComponent, ABuoyantDestructible), 0x00000000000a001d, Z_Construct_UClass_UBuoyantDestructibleComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyantDestructible.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructible.h"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("Category"), TEXT("BuoyantDestructible"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("ExposeFunctionCategories"), TEXT("Destruction,Components|Destructible,Buoyancy Settings,Advanced"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructible.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ABuoyantDestructible(Z_Construct_UClass_ABuoyantDestructible, TEXT("ABuoyantDestructible"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ABuoyantDestructible);
	UFunction* Z_Construct_UFunction_ACustomVehicleController_DrawBuoyancyPoints()
	{
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DrawBuoyancyPoints"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020600, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("--Custom debugging console commands--"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACustomVehicleController_EnableBuoyancy()
	{
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnableBuoyancy"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020600, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACustomVehicleController_EnterVehicle()
	{
		struct CustomVehicleController_eventEnterVehicle_Parms
		{
			APawn* Vehicle;
		};
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnterVehicle"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(CustomVehicleController_eventEnterVehicle_Parms));
			UProperty* NewProp_Vehicle = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Vehicle"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Vehicle, CustomVehicleController_eventEnterVehicle_Parms), 0x0000000000000080, Z_Construct_UClass_APawn_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Vehicle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACustomVehicleController_ExitVehicle()
	{
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ExitVehicle"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Vehicle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACustomVehicleController_GetIsDriving()
	{
		struct CustomVehicleController_eventGetIsDriving_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIsDriving"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14020400, 65535, sizeof(CustomVehicleController_eventGetIsDriving_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, CustomVehicleController_eventGetIsDriving_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, CustomVehicleController_eventGetIsDriving_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, CustomVehicleController_eventGetIsDriving_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Vehicle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ACustomVehicleController_NoRegister()
	{
		return ACustomVehicleController::StaticClass();
	}
	UClass* Z_Construct_UClass_ACustomVehicleController()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APlayerController();
			Z_Construct_UPackage_OceanPlugin();
			OuterClass = ACustomVehicleController::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800284;

				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_DrawBuoyancyPoints());
				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_EnableBuoyancy());
				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_EnterVehicle());
				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_ExitVehicle());
				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_GetIsDriving());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PlayerPawn = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PlayerPawn"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PlayerPawn, ACustomVehicleController), 0x0000000000000020, Z_Construct_UClass_APawn_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACustomVehicleController_DrawBuoyancyPoints()); // 18988422
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACustomVehicleController_EnableBuoyancy()); // 2070784443
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACustomVehicleController_EnterVehicle()); // 1270596017
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACustomVehicleController_ExitVehicle()); // 4206364779
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACustomVehicleController_GetIsDriving()); // 1526220956
				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Rendering Utilities|Transformation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("CustomVehicleController.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Custom player controller that has custom functionality to help possess vehicles."));
				MetaData->SetValue(NewProp_PlayerPawn, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ACustomVehicleController(Z_Construct_UClass_ACustomVehicleController, TEXT("ACustomVehicleController"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ACustomVehicleController);
	UClass* Z_Construct_UClass_AFishManager_NoRegister()
	{
		return AFishManager::StaticClass();
	}
	UClass* Z_Construct_UClass_AFishManager()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_OceanPlugin();
			OuterClass = AFishManager::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_playerType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("playerType"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(playerType, AFishManager), 0x0000000000000005, Z_Construct_UClass_UObject_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DebugMode, AFishManager, bool);
				UProperty* NewProp_DebugMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DebugMode"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DebugMode, AFishManager), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(DebugMode, AFishManager), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(attachToPlayer, AFishManager, bool);
				UProperty* NewProp_attachToPlayer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("attachToPlayer"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(attachToPlayer, AFishManager), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(attachToPlayer, AFishManager), sizeof(bool), true);
				UProperty* NewProp_underwaterBoxLength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("underwaterBoxLength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(underwaterBoxLength, AFishManager), 0x0000000000000005);
				UProperty* NewProp_maxZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("maxZ"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(maxZ, AFishManager), 0x0000000000000005);
				UProperty* NewProp_minZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("minZ"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(minZ, AFishManager), 0x0000000000000005);
				UProperty* NewProp_numInFlock = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("numInFlock"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(numInFlock, AFishManager), 0x0000000000000005);
				UProperty* NewProp_numInFlock_Inner = new(EC_InternalUseOnlyConstructor, NewProp_numInFlock, TEXT("numInFlock"), RF_Public|RF_Transient|RF_Native) UFloatProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				UProperty* NewProp_flockTypes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("flockTypes"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(flockTypes, AFishManager), 0x0000000000000005);
				UProperty* NewProp_flockTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_flockTypes, TEXT("flockTypes"), RF_Public|RF_Transient|RF_Native) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UObject_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Fish/FishManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_playerType, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_playerType, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_playerType, TEXT("ToolTip"), TEXT("Player Type"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("ToolTip"), TEXT("Player Type"));
				MetaData->SetValue(NewProp_attachToPlayer, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_attachToPlayer, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_attachToPlayer, TEXT("ToolTip"), TEXT("Attach fish manager to player?"));
				MetaData->SetValue(NewProp_underwaterBoxLength, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_underwaterBoxLength, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_underwaterBoxLength, TEXT("ToolTip"), TEXT("Length of underwater box"));
				MetaData->SetValue(NewProp_maxZ, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_maxZ, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_maxZ, TEXT("ToolTip"), TEXT("max Z of volume that is considered underwater"));
				MetaData->SetValue(NewProp_minZ, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_minZ, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_minZ, TEXT("ToolTip"), TEXT("min Z of volume that is considered underwater"));
				MetaData->SetValue(NewProp_numInFlock, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_numInFlock, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_numInFlock, TEXT("ToolTip"), TEXT("# of fish in respective flock"));
				MetaData->SetValue(NewProp_flockTypes, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_flockTypes, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_flockTypes, TEXT("ToolTip"), TEXT("Type of flocks to spawn"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AFishManager(Z_Construct_UClass_AFishManager, TEXT("AFishManager"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AFishManager);
	UFunction* Z_Construct_UFunction_AFlockFish_OnBeginOverlap()
	{
		struct FlockFish_eventOnBeginOverlap_Parms
		{
			AActor* otherActor;
			UPrimitiveComponent* otherComp;
			int32 otherBodyIndex;
			bool bFromSweep;
			FHitResult sweepResult;
		};
		UObject* Outer=Z_Construct_UClass_AFlockFish();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnBeginOverlap"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00480401, 65535, sizeof(FlockFish_eventOnBeginOverlap_Parms));
			UProperty* NewProp_sweepResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("sweepResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(sweepResult, FlockFish_eventOnBeginOverlap_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFromSweep, FlockFish_eventOnBeginOverlap_Parms, bool);
			UProperty* NewProp_bFromSweep = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFromSweep"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFromSweep, FlockFish_eventOnBeginOverlap_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bFromSweep, FlockFish_eventOnBeginOverlap_Parms), sizeof(bool), true);
			UProperty* NewProp_otherBodyIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherBodyIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(otherBodyIndex, FlockFish_eventOnBeginOverlap_Parms), 0x0000000000000080);
			UProperty* NewProp_otherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(otherComp, FlockFish_eventOnBeginOverlap_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_otherActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherActor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(otherActor, FlockFish_eventOnBeginOverlap_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
			MetaData->SetValue(NewProp_otherComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AFlockFish_OnEndOverlap()
	{
		struct FlockFish_eventOnEndOverlap_Parms
		{
			AActor* otherActor;
			UPrimitiveComponent* otherComp;
			int32 otherBodyIndex;
		};
		UObject* Outer=Z_Construct_UClass_AFlockFish();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnEndOverlap"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00080401, 65535, sizeof(FlockFish_eventOnEndOverlap_Parms));
			UProperty* NewProp_otherBodyIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherBodyIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(otherBodyIndex, FlockFish_eventOnEndOverlap_Parms), 0x0000000000000080);
			UProperty* NewProp_otherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(otherComp, FlockFish_eventOnEndOverlap_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_otherActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherActor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(otherActor, FlockFish_eventOnEndOverlap_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
			MetaData->SetValue(NewProp_otherComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AFlockFish_NoRegister()
	{
		return AFlockFish::StaticClass();
	}
	UClass* Z_Construct_UClass_AFlockFish()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APawn();
			Z_Construct_UPackage_OceanPlugin();
			OuterClass = AFlockFish::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;

				OuterClass->LinkChild(Z_Construct_UFunction_AFlockFish_OnBeginOverlap());
				OuterClass->LinkChild(Z_Construct_UFunction_AFlockFish_OnEndOverlap());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DebugMode, AFlockFish, bool);
				UProperty* NewProp_DebugMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DebugMode"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DebugMode, AFlockFish), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(DebugMode, AFlockFish), sizeof(bool), true);
				UProperty* NewProp_UpdateEveryTick = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpdateEveryTick"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(UpdateEveryTick, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_NumNeighborsToEvaluate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NumNeighborsToEvaluate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NumNeighborsToEvaluate, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_CustomZSeekMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomZSeekMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CustomZSeekMax, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_CustomZSeekMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomZSeekMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CustomZSeekMin, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_underwaterMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("underwaterMax"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(underwaterMax, AFlockFish), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_underwaterMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("underwaterMin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(underwaterMin, AFlockFish), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_playerType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("playerType"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(playerType, AFlockFish), 0x0000000000000005, Z_Construct_UClass_UObject_NoRegister());
				UProperty* NewProp_AvoidanceForce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceForce"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AvoidanceForce, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_AvoidForceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidForceMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AvoidForceMultiplier, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_SeekDecelerationMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SeekDecelerationMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SeekDecelerationMultiplier, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_ChaseAccelerationMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChaseAccelerationMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ChaseAccelerationMultiplier, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_FleeAccelerationMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FleeAccelerationMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FleeAccelerationMultiplier, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_FleeDistanceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FleeDistanceMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FleeDistanceMultiplier, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_SeperationDistanceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SeperationDistanceMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SeperationDistanceMultiplier, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_distBehindSpeedUpRange = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("distBehindSpeedUpRange"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(distBehindSpeedUpRange, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_hungerResetTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("hungerResetTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(hungerResetTime, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_turnFrequency = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("turnFrequency"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(turnFrequency, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_turnSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("turnSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(turnSpeed, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_maxSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("maxSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(maxSpeed, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_speed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("speed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(speed, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_followDist = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("followDist"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(followDist, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_neighborType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("neighborType"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(neighborType, AFlockFish), 0x0000000000000005, Z_Construct_UClass_UObject_NoRegister());
				UProperty* NewProp_preyTypes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("preyTypes"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(preyTypes, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_preyTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_preyTypes, TEXT("preyTypes"), RF_Public|RF_Transient|RF_Native) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UObject_NoRegister());
				UProperty* NewProp_enemyTypes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("enemyTypes"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(enemyTypes, AFlockFish), 0x0000000000000005);
				UProperty* NewProp_enemyTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_enemyTypes, TEXT("enemyTypes"), RF_Public|RF_Transient|RF_Native) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UObject_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(isLeader, AFlockFish, bool);
				UProperty* NewProp_isLeader = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("isLeader"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(isLeader, AFlockFish), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(isLeader, AFlockFish), sizeof(bool), true);
				UProperty* NewProp_FishInteractionSphere = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FishInteractionSphere"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(FishInteractionSphere, AFlockFish), 0x00000000000a001d, Z_Construct_UClass_USphereComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AFlockFish_OnBeginOverlap()); // 3012335908
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AFlockFish_OnEndOverlap()); // 82206694
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Fish/FlockFish.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("Category"), TEXT("TESTING"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("ToolTip"), TEXT("Run fish in debug mode"));
				MetaData->SetValue(NewProp_UpdateEveryTick, TEXT("Category"), TEXT("Optimization"));
				MetaData->SetValue(NewProp_UpdateEveryTick, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_UpdateEveryTick, TEXT("ToolTip"), TEXT("When set to 0, update every tick, otherwise update after specified time"));
				MetaData->SetValue(NewProp_NumNeighborsToEvaluate, TEXT("Category"), TEXT("Optimization"));
				MetaData->SetValue(NewProp_NumNeighborsToEvaluate, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_NumNeighborsToEvaluate, TEXT("ToolTip"), TEXT("Max number of neighbors to evaluate on a Tick (0 for all neighbors)"));
				MetaData->SetValue(NewProp_CustomZSeekMax, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_CustomZSeekMax, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_CustomZSeekMax, TEXT("ToolTip"), TEXT("Custom Z range for targeting (NULL will use full range of min/max)"));
				MetaData->SetValue(NewProp_CustomZSeekMin, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_CustomZSeekMin, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_CustomZSeekMin, TEXT("ToolTip"), TEXT("Custom Z range for targeting (NULL will use full range of min/max)"));
				MetaData->SetValue(NewProp_underwaterMax, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_underwaterMax, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_underwaterMax, TEXT("ToolTip"), TEXT("volume that is considered underwater"));
				MetaData->SetValue(NewProp_underwaterMin, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_underwaterMin, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_underwaterMin, TEXT("ToolTip"), TEXT("volume that is considered underwater"));
				MetaData->SetValue(NewProp_playerType, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_playerType, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_playerType, TEXT("ToolTip"), TEXT("Player the fish will avoid"));
				MetaData->SetValue(NewProp_AvoidanceForce, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_AvoidanceForce, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_AvoidanceForce, TEXT("ToolTip"), TEXT("Avoidance force"));
				MetaData->SetValue(NewProp_AvoidForceMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_AvoidForceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_AvoidForceMultiplier, TEXT("ToolTip"), TEXT("Avoid Distance Multiplier"));
				MetaData->SetValue(NewProp_SeekDecelerationMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_SeekDecelerationMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_SeekDecelerationMultiplier, TEXT("ToolTip"), TEXT("Multiplies with delta time since last tick when lerping to regular speed (While Seeking)"));
				MetaData->SetValue(NewProp_ChaseAccelerationMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_ChaseAccelerationMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_ChaseAccelerationMultiplier, TEXT("ToolTip"), TEXT("Multiplies with delta time since last tick when lerping to max speed (While Chasing)"));
				MetaData->SetValue(NewProp_FleeAccelerationMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_FleeAccelerationMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_FleeAccelerationMultiplier, TEXT("ToolTip"), TEXT("Multiplies with delta time since last tick when lerping to max speed (While Fleeing)"));
				MetaData->SetValue(NewProp_FleeDistanceMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_FleeDistanceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_FleeDistanceMultiplier, TEXT("ToolTip"), TEXT("Multiplies With Radius of Fish Interaction Sphere for Flee Distance"));
				MetaData->SetValue(NewProp_SeperationDistanceMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_SeperationDistanceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_SeperationDistanceMultiplier, TEXT("ToolTip"), TEXT("Multiplies With Radius of Fish Interaction Sphere for neighbor seperation"));
				MetaData->SetValue(NewProp_distBehindSpeedUpRange, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_distBehindSpeedUpRange, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_distBehindSpeedUpRange, TEXT("ToolTip"), TEXT("Go faster when fish is this distance behind leader"));
				MetaData->SetValue(NewProp_hungerResetTime, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_hungerResetTime, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_hungerResetTime, TEXT("ToolTip"), TEXT("time after eating until it is hungry again"));
				MetaData->SetValue(NewProp_turnFrequency, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_turnFrequency, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_turnFrequency, TEXT("ToolTip"), TEXT("Frequency of turning ( turn every \"turnFrequency\" seconds)"));
				MetaData->SetValue(NewProp_turnSpeed, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_turnSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_turnSpeed, TEXT("ToolTip"), TEXT("Speed at which the fish turns (Try to have predators be slightly faster)"));
				MetaData->SetValue(NewProp_maxSpeed, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_maxSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_maxSpeed, TEXT("ToolTip"), TEXT("Max Speed"));
				MetaData->SetValue(NewProp_speed, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_speed, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_speed, TEXT("ToolTip"), TEXT("Defualt Speed"));
				MetaData->SetValue(NewProp_followDist, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_followDist, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_followDist, TEXT("ToolTip"), TEXT("Distance to that fish will try to remain behind leader"));
				MetaData->SetValue(NewProp_neighborType, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_neighborType, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_neighborType, TEXT("ToolTip"), TEXT("Neighbor type of the fish ( typically itself, but needed for code atm)"));
				MetaData->SetValue(NewProp_preyTypes, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_preyTypes, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_preyTypes, TEXT("ToolTip"), TEXT("Prey that the fish will attack"));
				MetaData->SetValue(NewProp_enemyTypes, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_enemyTypes, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_enemyTypes, TEXT("ToolTip"), TEXT("Enemies that fish will flee from"));
				MetaData->SetValue(NewProp_isLeader, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_isLeader, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_isLeader, TEXT("ToolTip"), TEXT("Is this fish a leader"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("Category"), TEXT("Interaction"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("ToolTip"), TEXT("Fish interaction sphere"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AFlockFish(Z_Construct_UClass_AFlockFish, TEXT("AFlockFish"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AFlockFish);
	UEnum* Z_Construct_UEnum_OceanPlugin_EFollowMethod()
	{
		UPackage* Outer=Z_Construct_UPackage_OceanPlugin();
		extern uint32 Get_Z_Construct_UEnum_OceanPlugin_EFollowMethod_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EFollowMethod"), 0, Get_Z_Construct_UEnum_OceanPlugin_EFollowMethod_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EFollowMethod"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("LookAtLocation")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FollowCamera")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FollowPawn")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Stationary")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EFollowMethod_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_OceanPlugin_EFollowMethod_CRC() { return 1527765919U; }
	UClass* Z_Construct_UClass_UInfiniteSystemComponent_NoRegister()
	{
		return UInfiniteSystemComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UInfiniteSystemComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_OceanPlugin();
			OuterClass = UInfiniteSystemComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ScaleMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleMax, UInfiniteSystemComponent), 0x0000000000000005);
				UProperty* NewProp_ScaleMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleMin, UInfiniteSystemComponent), 0x0000000000000005);
				UProperty* NewProp_ScaleStartDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleStartDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleStartDistance, UInfiniteSystemComponent), 0x0000000000000005);
				UProperty* NewProp_ScaleDistanceFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleDistanceFactor"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleDistanceFactor, UInfiniteSystemComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ScaleByDistance, UInfiniteSystemComponent, bool);
				UProperty* NewProp_ScaleByDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleByDistance"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ScaleByDistance, UInfiniteSystemComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(ScaleByDistance, UInfiniteSystemComponent), sizeof(bool), true);
				UProperty* NewProp_MaxLookAtDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxLookAtDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxLookAtDistance, UInfiniteSystemComponent), 0x0000000000000005);
				UProperty* NewProp_GridSnapSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GridSnapSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GridSnapSize, UInfiniteSystemComponent), 0x0000000000000005);
				UProperty* NewProp_FollowMethod = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FollowMethod"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(FollowMethod, UInfiniteSystemComponent), 0x0000000000000005, Z_Construct_UEnum_OceanPlugin_EFollowMethod());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(UpdateInEditor, UInfiniteSystemComponent, bool);
				UProperty* NewProp_UpdateInEditor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpdateInEditor"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(UpdateInEditor, UInfiniteSystemComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(UpdateInEditor, UInfiniteSystemComponent), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility LOD PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("InfiniteSystemComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Infinite Ocean Plane System.\nFollows camera and scales by distance to make a plane appear as infinite."));
				MetaData->SetValue(NewProp_ScaleMax, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleMax, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_ScaleMin, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleMin, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_ScaleStartDistance, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleStartDistance, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_ScaleDistanceFactor, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleDistanceFactor, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_ScaleByDistance, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleByDistance, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_MaxLookAtDistance, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_MaxLookAtDistance, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_GridSnapSize, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_GridSnapSize, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_FollowMethod, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_FollowMethod, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_UpdateInEditor, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_UpdateInEditor, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UInfiniteSystemComponent(Z_Construct_UClass_UInfiniteSystemComponent, TEXT("UInfiniteSystemComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UInfiniteSystemComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FTimeDate()
	{
		UPackage* Outer=Z_Construct_UPackage_OceanPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FTimeDate_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("TimeDate"), sizeof(FTimeDate), Get_Z_Construct_UScriptStruct_FTimeDate_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TimeDate"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTimeDate>, EStructFlags(0x00000001));
			UProperty* NewProp_Year = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Year"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Year, FTimeDate), 0x0000000000000005);
			UProperty* NewProp_Month = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Month"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Month, FTimeDate), 0x0000000000000005);
			UProperty* NewProp_Day = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Day"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Day, FTimeDate), 0x0000000000000005);
			UProperty* NewProp_Hour = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Hour"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Hour, FTimeDate), 0x0000000000000005);
			UProperty* NewProp_Minute = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Minute"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Minute, FTimeDate), 0x0000000000000005);
			UProperty* NewProp_Second = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Second"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Second, FTimeDate), 0x0000000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("USTRUCT(BlueprintType)\nstruct FLocation\n      {\n      GENERATED_USTRUCT_BODY()\n\n\n@Name: FLocation\n@Description: Constructs a new FLocation instance.\n\n      FLocation() { FLocation(0.0f, 0.0f); }\n\n\n@Name: FLocation\n@Description: Constructs a new FLocation instance.\n\n@param: float - Latitude value (-90 to +90)\n@param: float - Longitude value (-180 to +180)\n\n      FLocation(float latitude, float longitude) { Latitude = latitude; Longitude = longitude > 180.0f ? longitude - 360.0f : longitude; }\n\n       The latitude coordinate for the local location (valid value range -90 to +90 degrees).\n      UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = \"Location\")\n      float Latitude;\n\n       The longitude coordinate for the local location (valid value range -180 to +180 degrees).\n      UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = \"Location\")\n      float Longitude;\n\n       Direction for calculating the Longitude value (East [false] = 0 to 180, West [true] = 180 to 360)\n      UPROPERTY(BlueprintReadOnly, Category = \"Location\")\n      bool IsLongitudeWest = Longitude < 0;\n\n       Direction for calculating the Latitude value (North [false] = 0 to +90, South [true] = 0 to -90)\n      UPROPERTY(BlueprintReadOnly, Category = \"Location\")\n      bool IsLatitudeSouth = Latitude < 0;\n\n      bool operator==(const FLocation& other) const\n              {\n              return (Latitude == other.Latitude) && (Longitude == other.Longitude);\n              }\n\n      bool operator!=(const FLocation& other) const\n              {\n              return (Latitude != other.Latitude) || (Longitude != other.Longitude);\n              }\n\n      };"));
			MetaData->SetValue(NewProp_Year, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Year, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Year, TEXT("ToolTip"), TEXT("The year value for this time and date."));
			MetaData->SetValue(NewProp_Month, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Month, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Month, TEXT("ToolTip"), TEXT("The month value for this time and date."));
			MetaData->SetValue(NewProp_Day, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Day, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Day, TEXT("ToolTip"), TEXT("The day value for this time and date."));
			MetaData->SetValue(NewProp_Hour, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Hour, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Hour, TEXT("ToolTip"), TEXT("The hour value for this time and date."));
			MetaData->SetValue(NewProp_Minute, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Minute, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Minute, TEXT("ToolTip"), TEXT("The minute value for this time and date."));
			MetaData->SetValue(NewProp_Second, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Second, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Second, TEXT("ToolTip"), TEXT("The second (plus fractional second) value for this time and date."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTimeDate_CRC() { return 765425324U; }
	UPackage* Z_Construct_UPackage_OceanPlugin()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/OceanPlugin")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0x9BCC439B;
			Guid.B = 0x8E2933D0;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
